# Объяснение выбора структуры данных и решения задачи 
1) Структура имеет 3 поля, каждое из которых может быть использовано в роли ключа
2) Поиск должен осуществляться не медленнее O(log n)

Из данных пунктов следует:
- Не получится просто использовать один тип структуры данных, нужна их комбинация -
- Ни массив, ни список не дают нам достаточно быстрого поиска 
- В случае сбалансированных бинарных деревьев поиск осуществляется за O(log n), для уменьшения затрат по памяти, можно использовать в качестве ключа значение поля. В таком случае для хранения объекта с 3-мя полями и одинаково быстрого поиска по любому из полей, можно использовать 3 дерева. Для каждого: ключом будет текущее поле, а значение - указатели на ноды соседних деревьев, содержащие остальные поля данного объекта.   
- Предыдущую идею можно улучшить, воспользовавшись хэш-таблицой. Она позволяет нам находить элементы за O(1) в лучшем случае, и в зависимости от структуры bucket'ов за O(n)(bucket из списка), O(log n)(bucket из сбалансированного дерева). 
 *рисунок схемы из 3-х деревьев*

# Установка и запуск

```
  //download sources
  git clone https://github.com/ssshahzod/TrialTasks.git
  cd TrialTasks
```

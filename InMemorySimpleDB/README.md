# Объяснение выбора структуры данных и решения задачи 
1) Структура имеет 3 поля, каждое из которых может быть использовано в роли ключа
2) Поиск должен осуществляться не медленнее O(log n)

Из данных пунктов следует:
- Не получится просто использовать один тип структуры данных, нужна их комбинация
- Ни массив, ни список не дают нам достаточно быстрого поиска 
- В случае сбалансированных бинарных деревьев поиск осуществляется за O(log n), для уменьшения затрат по памяти, можно использовать в качестве ключа значение поля. В таком случае для хранения объекта с 3-мя полями и одинаково быстрого поиска по любому из полей, можно использовать 3 дерева. Для каждого: ключом будет текущее поле, а значение - указатели на ноды соседних деревьев, содержащие остальные поля данного объекта.   
### Схема с 3-мя деревьями. Для упрощения приведены 2 связи.
![изображение](https://user-images.githubusercontent.com/55853125/235345865-d541cb4d-53e6-48b5-80aa-846a3f206899.png)


- Предыдущую идею можно улучшить, воспользовавшись хэш-таблицой. Она позволяет нам находить элементы за O(1) в лучшем случае, и в зависимости от структуры bucket'ов за O(n)(bucket из списка), O(log n)(bucket из сбалансированного дерева). 
### Схема с 3-мя хэш-таблицами. Для упрощения приведены 2 связи.
![изображение](https://user-images.githubusercontent.com/55853125/235346153-1391e4ea-3627-49e9-8038-e9933edffec8.png)


# Установка и запуск

```
  //download sources
  git clone https://github.com/ssshahzod/TrialTasks.git
  cd TrialTasks
```

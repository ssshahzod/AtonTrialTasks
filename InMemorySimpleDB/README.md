# Объяснение выбора структуры данных и решения задачи 
1) Структура имеет 3 поля, каждое из которых может быть использовано в роли ключа
2) Поиск должен осуществляться не медленнее O(log n)

Из данных пунктов следует:
- Не получится просто использовать один тип структуры данных, нужна их комбинация
- Ни массив, ни список не дают нам достаточно быстрого поиска 
- В случае сбалансированных бинарных деревьев поиск осуществляется за O(log n), для уменьшения затрат по памяти, можно использовать в качестве ключа значение поля. В таком случае его не придется хранить, а для хранения объекта с 3-мя полями и одинаково быстрого поиска по любому из полей, можно использовать 3 дерева. Для каждого: ключом будет текущее поле, а значение - указатели на ноды соседних деревьев, содержащие остальные поля данного объекта. Затраты по памяти в худшем случае будут составлять O(n).
### Схема с 3-мя деревьями. Для упрощения приведены 2 связи.
![изображение](https://user-images.githubusercontent.com/55853125/235345865-d541cb4d-53e6-48b5-80aa-846a3f206899.png)


- Предыдущую идею можно улучшить, воспользовавшись хэш-таблицой. Она позволяет нам находить элементы за O(1) в лучшем случае, и в зависимости от структуры bucket'ов за O(n)(bucket из списка), O(log n)(bucket из сбалансированного дерева). Однако затраты по памяти в таком случае могут возрасти, так как не гарантированно, что load factor = 1, т.е. таблица будет заполнена равномерно, и будут возникать пустоты.
### Схема с 3-мя хэш-таблицами. Для упрощения приведены 2 связи.
![изображение](https://user-images.githubusercontent.com/55853125/235346153-1391e4ea-3627-49e9-8038-e9933edffec8.png)

## Вывод
 - Исходя из предыдущих рассуждений и условия задания, оптимальным решением будет использование 3-х сбалансированных деревьев, т.к. поиск осуществляется за O(log n), а затраты памяти более оптимальны, чем при использовании 3-х хэш-таблиц.
# Установка и запуск

```
  //download sources
  git clone https://github.com/ssshahzod/TrialTasks.git
  cd TrialTasks/InMemorySimpleDB
```
